{"id":"node_modules/@ew-did-registry/did-resolver-interface/dist/models/operator.js","dependencies":[{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-resolver-interface\\dist\\models\\operator.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-resolver-interface\\src\\models\\operator.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\package.json","includedInParent":true,"mtime":1643668307056},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-resolver-interface\\package.json","includedInParent":true,"mtime":1642814787149}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyTags = exports.Algorithms = exports.Encoding = exports.PubKeyType = exports.DIDAttribute = void 0;\n/**\n * Currently, there are three types of DID Attributes, this can be potentially extended\n */\nvar DIDAttribute;\n(function (DIDAttribute) {\n    DIDAttribute[\"PublicKey\"] = \"pub\";\n    DIDAttribute[\"Authenticate\"] = \"auth\";\n    DIDAttribute[\"ServicePoint\"] = \"svc\";\n})(DIDAttribute = exports.DIDAttribute || (exports.DIDAttribute = {}));\n/**\n * The two main types of public keys are, in turn, verification key and signature authentication key\n */\nvar PubKeyType;\n(function (PubKeyType) {\n    PubKeyType[\"SignatureAuthentication2018\"] = \"sigAuth\";\n    PubKeyType[\"VerificationKey2018\"] = \"veriKey\";\n})(PubKeyType = exports.PubKeyType || (exports.PubKeyType = {}));\n/**\n * Encoding specifies the format in which the public key is store\n */\nvar Encoding;\n(function (Encoding) {\n    Encoding[\"HEX\"] = \"hex\";\n    Encoding[\"BASE64\"] = \"base64\";\n    Encoding[\"PEM\"] = \"pem\";\n})(Encoding = exports.Encoding || (exports.Encoding = {}));\n/**\n * Algorithms specifies, which algorithm has to be used with a particular public key\n */\nvar Algorithms;\n(function (Algorithms) {\n    Algorithms[\"ED25519\"] = \"Ed25519\";\n    Algorithms[\"RSA\"] = \"Rsa\";\n    Algorithms[\"ECDSA\"] = \"ECDSA\";\n    Algorithms[\"Secp256k1\"] = \"Secp256k1\";\n})(Algorithms = exports.Algorithms || (exports.Algorithms = {}));\n/**\n * KeyTags specifies the tags associated with different purposes of the keys\n */\nvar KeyTags;\n(function (KeyTags) {\n    KeyTags[\"OWNER\"] = \"key-owner\";\n})(KeyTags = exports.KeyTags || (exports.KeyTags = {}));\n"},"sourceMaps":{"js":{"version":3,"file":"operator.js","sourceRoot":"","sources":["../../src/models/operator.ts"],"names":[],"mappings":";;;AAAA;;GAEG;AACH,IAAY,YAEX;AAFD,WAAY,YAAY;IACtB,iCAAiB,CAAA;IAAE,qCAAqB,CAAA;IAAE,oCAAoB,CAAA;AAChE,CAAC,EAFW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAEvB;AAED;;GAEG;AACH,IAAY,UAEX;AAFD,WAAY,UAAU;IACpB,qDAAuC,CAAA;IAAE,6CAA+B,CAAA;AAC1E,CAAC,EAFW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAErB;AAED;;GAEG;AACH,IAAY,QAEX;AAFD,WAAY,QAAQ;IAClB,uBAAW,CAAA;IAAE,6BAAiB,CAAA;IAAE,uBAAW,CAAA;AAC7C,CAAC,EAFW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAEnB;AAED;;GAEG;AACH,IAAY,UAEX;AAFD,WAAY,UAAU;IACpB,iCAAmB,CAAA;IAAE,yBAAW,CAAA;IAAE,6BAAe,CAAA;IAAE,qCAAuB,CAAA;AAC5E,CAAC,EAFW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAErB;AAED;;GAEG;AACH,IAAY,OAEX;AAFD,WAAY,OAAO;IACjB,8BAAmB,CAAA;AACrB,CAAC,EAFW,OAAO,GAAP,eAAO,KAAP,eAAO,QAElB","sourcesContent":["/**\n * Currently, there are three types of DID Attributes, this can be potentially extended\n */\nexport enum DIDAttribute {\n  PublicKey = 'pub', Authenticate = 'auth', ServicePoint = 'svc'\n}\n\n/**\n * The two main types of public keys are, in turn, verification key and signature authentication key\n */\nexport enum PubKeyType {\n  SignatureAuthentication2018 = 'sigAuth', VerificationKey2018 = 'veriKey'\n}\n\n/**\n * Encoding specifies the format in which the public key is store\n */\nexport enum Encoding {\n  HEX = 'hex', BASE64 = 'base64', PEM = 'pem'\n}\n\n/**\n * Algorithms specifies, which algorithm has to be used with a particular public key\n */\nexport enum Algorithms {\n  ED25519 = 'Ed25519', RSA = 'Rsa', ECDSA = 'ECDSA', Secp256k1 = 'Secp256k1'\n}\n\n/**\n * KeyTags specifies the tags associated with different purposes of the keys\n */\nexport enum KeyTags {\n  OWNER = 'key-owner'\n}\n\n/** This interface represents the attribute payload\n * TODO : avoid use of IAttributePayload, reuse IPublicKey and IServiceEndpoint\n*/\nexport interface IAttributePayload {\n  id?: string;\n  type?: string;\n  publicKey?: string;\n  serviceEndpoint?: string;\n  tag?: string;\n  hash?: string;\n  hashAlg?: string;\n}\n\n/**\n * Data used to update DID Document. To update the public key you need to set its value in value\n * field, and to set authentication method, the delegate's Ethereum address must be set in the\n * delegate field\n */\nexport interface IUpdateData {\n  encoding?: Encoding;\n  algo?: Algorithms;\n  type: PubKeyType | DIDAttribute;\n  value?: IAttributePayload;\n  delegate?: string;\n}\n\nexport type IUpdateAttributeData = Omit<IUpdateData, 'delegate'> & { value: IAttributePayload };\n\nexport type IUpdateDelegateData = Omit<IUpdateData, 'value'> & { delegate: string };\n"]}},"error":null,"hash":"b0b072a1de7f7d3f2055d2cda554af30","cacheData":{"env":{}}}