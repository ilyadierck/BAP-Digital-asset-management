{"id":"node_modules/@ew-did-registry/claims/dist/claimsVerifier/claimsVerifier.js","dependencies":[{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claimsVerifier\\claimsVerifier.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\src\\claimsVerifier\\claimsVerifier.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\package.json","includedInParent":true,"mtime":1643668307056},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\package.json","includedInParent":true,"mtime":1642815195336},{"name":"sjcl","loc":{"line":18,"column":23},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claimsVerifier\\claimsVerifier.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\sjcl\\sjcl.js"},{"name":"@ew-did-registry/did-resolver-interface","loc":{"line":19,"column":41},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claimsVerifier\\claimsVerifier.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-resolver-interface\\dist\\index.js"},{"name":"crypto","loc":{"line":20,"column":41},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claimsVerifier\\claimsVerifier.js","resolved":"C:\\Users\\Ilya\\AppData\\Roaming\\npm\\node_modules\\parcel-bundler\\node_modules\\crypto-browserify\\index.js"},{"name":"../claims","loc":{"line":21,"column":25},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claimsVerifier\\claimsVerifier.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\claims\\dist\\claims\\index.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ClaimsVerifier = void 0;\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nconst sjcl_1 = require(\"sjcl\");\nconst did_resolver_interface_1 = require(\"@ew-did-registry/did-resolver-interface\");\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst claims_1 = require(\"../claims\");\nclass ClaimsVerifier extends claims_1.Claims {\n    /**\n     * Verifies integrity of the claim, the claim is issued by the user\n     *  delegate and the authenticity of the issuer's signature\n     *\n     * @example\n     * ```typescript\n     * import { ClaimsVerifier } from '@ew-did-registry/claims';\n     * import { Keys } from '@ew-did-registry/keys';\n     *\n     * const keys = new Keys();\n     * const claims = new ClaimsVerifier(verifier);\n     * const verified = claims.verifyPublicProof(issuedToken);\n     * ```\n     * @param { string } token containing proof data\n     * @returns { Promise<void> } whether the proof was succesfull\n     * @throws if the proof failed\n     */\n    verifyPublicProof(claimUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.verify(claimUrl);\n        });\n    }\n    /**\n    * Checks issuer signature on issued token and user signature on proof token\n    * and verifies that proof and private data mathches to each other\n    *\n    * @example\n    * ```typescript\n    * import { ClaimsVerifier } from '@ew-did-registry/claims';\n    * import { Keys } from '@ew-did-registry/keys';\n    *\n    * const keys = new Keys();\n    * const claims = new ClaimsVerifier(verifier);\n    * const verified = claims.verifyPrivateProof(proofToken);\n    * ```\n    * @param { string } proofToken contains proof data\n    * @param { string } privateToken contains private data\n    * @returns { Promise<void> } whether the proof was succesfull\n    * @throws if the proof failed\n    */\n    verifyPrivateProof(proofToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { claimUrl } = this.jwt.decode(proofToken);\n            const privateClaim = yield this.verify(claimUrl);\n            const curve = sjcl_1.ecc.curves.k256;\n            const g = curve.G;\n            const proofClaim = this.jwt.decode(proofToken);\n            if (!(yield this.verifySignature(proofToken, proofClaim.signer))) {\n                throw new Error('Invalid signature');\n            }\n            if (!this.document\n                .isValidDelegate(did_resolver_interface_1.DelegateTypes.verification, privateClaim.signer, privateClaim.did)) {\n                throw new Error('Issuer isn\\'t a use\\'r delegate');\n            }\n            const { proofData } = proofClaim;\n            // eslint-disable-next-line no-restricted-syntax\n            Object.entries(privateClaim.claimData).forEach(([key, value]) => {\n                const field = proofData[key];\n                if (field.encrypted) {\n                    const PK = curve.fromBits(value);\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n                    // @ts-ignore\n                    let { h, s } = field.value;\n                    h = curve.fromBits(h);\n                    s = sjcl_1.bn.fromBits(s);\n                    const c = sjcl_1.bn.fromBits(sjcl_1.hash.sha256.hash(g.x.toBits()\n                        .concat(h.toBits())\n                        .concat(PK.toBits())));\n                    const left = g.mult(s);\n                    const right = PK.mult(c).toJac().add(h).toAffine();\n                    if (!sjcl_1.bitArray.equal(left.toBits(), right.toBits())) {\n                        throw new Error('User didn\\'t prove the knowledge of the private data');\n                    }\n                }\n                else {\n                    const fieldHash = crypto_1.default.createHash('sha256').update(field.value).digest('hex');\n                    // eslint-disable-next-line new-cap\n                    const PK = g.mult(new sjcl_1.bn(fieldHash));\n                    const bitsPK = PK.toBits();\n                    if (!sjcl_1.bitArray.equal(value, bitsPK)) {\n                        throw new Error('Disclosed field does not correspond to stored field');\n                    }\n                }\n            });\n        });\n    }\n}\nexports.ClaimsVerifier = ClaimsVerifier;\n"},"sourceMaps":{"js":{"version":3,"file":"claimsVerifier.js","sourceRoot":"","sources":["../../src/claimsVerifier/claimsVerifier.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport {\n  bn, hash, ecc, bitArray,\n} from 'sjcl';\nimport { DelegateTypes } from '@ew-did-registry/did-resolver-interface';\nimport crypto from 'crypto';\nimport { Claims } from '../claims';\nimport { IClaimsVerifier } from '../interface';\nimport { IProofClaim, IPublicClaim } from '../models';\n\nexport class ClaimsVerifier extends Claims implements IClaimsVerifier {\n  /**\n   * Verifies integrity of the claim, the claim is issued by the user\n   *  delegate and the authenticity of the issuer's signature\n   *\n   * @example\n   * ```typescript\n   * import { ClaimsVerifier } from '@ew-did-registry/claims';\n   * import { Keys } from '@ew-did-registry/keys';\n   *\n   * const keys = new Keys();\n   * const claims = new ClaimsVerifier(verifier);\n   * const verified = claims.verifyPublicProof(issuedToken);\n   * ```\n   * @param { string } token containing proof data\n   * @returns { Promise<void> } whether the proof was succesfull\n   * @throws if the proof failed\n   */\n  async verifyPublicProof(claimUrl: string): Promise<IPublicClaim> {\n    return this.verify(claimUrl) as Promise<IPublicClaim>;\n  }\n\n  /**\n  * Checks issuer signature on issued token and user signature on proof token\n  * and verifies that proof and private data mathches to each other\n  *\n  * @example\n  * ```typescript\n  * import { ClaimsVerifier } from '@ew-did-registry/claims';\n  * import { Keys } from '@ew-did-registry/keys';\n  *\n  * const keys = new Keys();\n  * const claims = new ClaimsVerifier(verifier);\n  * const verified = claims.verifyPrivateProof(proofToken);\n  * ```\n  * @param { string } proofToken contains proof data\n  * @param { string } privateToken contains private data\n  * @returns { Promise<void> } whether the proof was succesfull\n  * @throws if the proof failed\n  */\n  async verifyPrivateProof(proofToken: string): Promise<void> {\n    const { claimUrl } = this.jwt.decode(proofToken) as { claimUrl: string };\n    const privateClaim = await this.verify(claimUrl);\n    const curve: sjcl.SjclEllipticalCurve = ecc.curves.k256;\n    const g = curve.G;\n    const proofClaim: IProofClaim = this.jwt.decode(proofToken) as IProofClaim;\n    if (!(await this.verifySignature(proofToken, proofClaim.signer))) {\n      throw new Error('Invalid signature');\n    }\n    if (\n      !this.document\n        .isValidDelegate(\n          DelegateTypes.verification,\n          privateClaim.signer,\n          privateClaim.did,\n        )\n    ) {\n      throw new Error('Issuer isn\\'t a use\\'r delegate');\n    }\n\n    const { proofData } = proofClaim;\n    // eslint-disable-next-line no-restricted-syntax\n    Object.entries(privateClaim.claimData).forEach(([key, value]) => {\n      const field = proofData[key];\n      if (field.encrypted) {\n        const PK = curve.fromBits(value as []);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n        // @ts-ignore\n        let { h, s } = field.value;\n        h = curve.fromBits(h);\n        s = bn.fromBits(s);\n        const c = bn.fromBits(\n          hash.sha256.hash(\n            g.x.toBits()\n              .concat(h.toBits())\n              .concat(PK.toBits()),\n          ),\n        );\n        const left = g.mult(s);\n        const right = PK.mult(c).toJac().add(h).toAffine();\n        if (!bitArray.equal(left.toBits(), right.toBits())) {\n          throw new Error('User didn\\'t prove the knowledge of the private data');\n        }\n      } else {\n        const fieldHash = crypto.createHash('sha256').update(field.value as string).digest('hex');\n        // eslint-disable-next-line new-cap\n        const PK = g.mult(new bn(fieldHash));\n        const bitsPK = PK.toBits();\n\n        if (!bitArray.equal(value as [], bitsPK)) {\n          throw new Error('Disclosed field does not correspond to stored field');\n        }\n      }\n    });\n  }\n}\n"]}},"error":null,"hash":"6705f89b523f8a728ff2660e372a114e","cacheData":{"env":{}}}