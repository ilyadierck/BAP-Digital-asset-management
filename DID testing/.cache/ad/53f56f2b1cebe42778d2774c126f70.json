{"id":"node_modules/@ew-did-registry/did-ethr-resolver/dist/implementations/resolver.js","dependencies":[{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\src\\implementations\\resolver.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\package.json","includedInParent":true,"mtime":1643668307056},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\package.json","includedInParent":true,"mtime":1642814787149},{"name":"ethers","loc":{"line":12,"column":25},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\ethers\\lib.esm\\index.js"},{"name":"@ew-did-registry/did-resolver-interface","loc":{"line":13,"column":41},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-resolver-interface\\dist\\index.js"},{"name":"@ew-did-registry/did","loc":{"line":14,"column":22},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did\\dist\\index.js"},{"name":"../constants","loc":{"line":15,"column":28},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\constants\\index.js"},{"name":"../functions","loc":{"line":16,"column":28},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\functions\\index.js"},{"name":"..","loc":{"line":17,"column":20},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\implementations\\resolver.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\did-ethr-resolver\\dist\\index.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ethers_1 = require(\"ethers\");\nconst did_resolver_interface_1 = require(\"@ew-did-registry/did-resolver-interface\");\nconst did_1 = require(\"@ew-did-registry/did\");\nconst constants_1 = require(\"../constants\");\nconst functions_1 = require(\"../functions\");\nconst __1 = require(\"..\");\nconst { formatBytes32String } = ethers_1.utils;\n/**\n * To support different methods compliant with ERC1056, the user/developer simply has to provide\n * different resolver settings. The default resolver settings are provided in the 'constants' folder\n * Any settings that follow the IResolverSettings interface are valid.\n *\n * The read functionality is implemented in Resolver class. If one wants to adjust it or create her\n * own implementation (for example according to ERC725), one could use this class as a\n * starting point.\n * All the functionality supporting document resolution is stored in 'functions' folder.\n */\nclass Resolver {\n    /**\n     * Constructor\n     *\n     * @param settings - Settings to connect to Ethr registry\n     * @param provider - Ethers provider. Can be obtained from getProvider(providerSettings)\n     */\n    constructor(provider, settings) {\n        this._provider = provider;\n        this.settings = Object.assign({ abi: constants_1.ethrReg.abi, method: did_1.Methods.Erc1056 }, settings);\n        this._contract = new ethers_1.Contract(settings.address, this.settings.abi, this._provider);\n    }\n    /**\n     * Resolve DID Document for a given did\n     *\n     * @example\n     * ```typescript\n     * import { Resolver } from '@ew-did-registry/did-resolver';\n     *\n     * const resolver = new Resolver(provider, resolverSettings);\n     * const didDocument = await resolver.read(did);\n     * ```\n     *\n     * @param did - entity identifier, which is associated with DID Document\n     * @returns {Promise<IDIDDocument>}\n     */\n    _read(did, selector) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const match = did.match(did_1.DIDPattern);\n            if (!match) {\n                throw new Error('Invalid did provided');\n            }\n            const address = match[1];\n            const _document = {\n                owner: address,\n                topBlock: ethers_1.BigNumber.from(0),\n                authentication: {},\n                publicKey: {},\n                service: {},\n                attributes: new Map(),\n            };\n            try {\n                yield functions_1.fetchDataFromEvents(did, _document, this.settings, this._contract, this._provider, selector);\n                const document = functions_1.wrapDidDocument(did, _document);\n                return document;\n            }\n            catch (error) {\n                if (error.toString() === 'Error: Blockchain address did not interact with smart contract') {\n                    const didDocument = functions_1.wrapDidDocument(did, _document);\n                    return didDocument;\n                }\n                throw error;\n            }\n        });\n    }\n    read(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._read(did);\n        });\n    }\n    readAttribute(did, selector) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doc = yield this._read(did, selector);\n            return functions_1.query(doc, selector);\n        });\n    }\n    /**\n     * Returns the Ethereum address of current identity owner\n     *\n     * @param { string } did - did of identity of interest\n     * @returns Promise<string>\n     */\n    identityOwner(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [, , id] = did.split(':');\n            let owner;\n            try {\n                owner = yield this._contract.identityOwner(id);\n            }\n            catch (error) {\n                throw new Error(error);\n            }\n            return owner;\n        });\n    }\n    /**\n     * Performs the check if the delegate is valid for particular did\n     * Return boolean\n     *\n     * @param { string } identityDID - did of identity of interest\n     * @param { DelegateTypes } delegateType - type of delegate of interest\n     * @param { delegateDID } did - did of delegate of interest\n     * @returns Promise<boolean>\n     */\n    validDelegate(identityDID, delegateType, delegateDID) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bytesType = formatBytes32String(delegateType);\n            const [, , identityAddress] = identityDID.split(':');\n            const [, , delegateAddress] = delegateDID.split(':');\n            let valid;\n            try {\n                valid = yield this._contract.validDelegate(identityAddress, bytesType, delegateAddress);\n            }\n            catch (error) {\n                throw new Error(error);\n            }\n            return valid;\n        });\n    }\n    readOwnerPubKey(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const selector = {\n                publicKey: { id: `${did}#${did_resolver_interface_1.KeyTags.OWNER}` },\n            };\n            const pk = yield this.readAttribute(did, selector);\n            const publicKeyHex = pk ? pk.publicKeyHex : undefined;\n            if (!publicKeyHex) {\n                return undefined;\n            }\n            if (publicKeyHex.length === __1.compressedSecp256k1KeyLength + 2 && publicKeyHex.substring(0, 2) === '0x') {\n                return publicKeyHex.substring(2);\n            }\n            if (publicKeyHex.length === __1.compressedSecp256k1KeyLength) {\n                return publicKeyHex;\n            }\n            return undefined;\n        });\n    }\n    readFromBlock(did, topBlock) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [, , address] = did.split(':');\n            const _document = {\n                owner: address,\n                topBlock,\n                authentication: {},\n                publicKey: {},\n                service: {},\n                attributes: new Map(),\n            };\n            yield functions_1.fetchDataFromEvents(did, _document, this.settings, this._contract, this._provider);\n            return Object.assign({}, _document);\n        });\n    }\n    lastBlock(did) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [, , address] = did.split(':');\n            return this._contract.changed(address);\n        });\n    }\n}\nexports.default = Resolver;\n"},"sourceMaps":{"js":{"version":3,"file":"resolver.js","sourceRoot":"","sources":["../../src/implementations/resolver.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Contract, providers, utils, BigNumber,\n} from 'ethers';\nimport {\n  DelegateTypes,\n  IAuthentication,\n  IDIDDocument,\n  IDIDLogData,\n  IPublicKey,\n  IResolver,\n  IServiceEndpoint,\n  RegistrySettings,\n  KeyTags,\n  DocumentSelector,\n} from '@ew-did-registry/did-resolver-interface';\nimport { Methods, DIDPattern } from '@ew-did-registry/did';\nimport { ethrReg } from '../constants';\nimport { fetchDataFromEvents, wrapDidDocument, query } from '../functions';\nimport { compressedSecp256k1KeyLength } from '..';\n\nconst { formatBytes32String } = utils;\n\n/**\n * To support different methods compliant with ERC1056, the user/developer simply has to provide\n * different resolver settings. The default resolver settings are provided in the 'constants' folder\n * Any settings that follow the IResolverSettings interface are valid.\n *\n * The read functionality is implemented in Resolver class. If one wants to adjust it or create her\n * own implementation (for example according to ERC725), one could use this class as a\n * starting point.\n * All the functionality supporting document resolution is stored in 'functions' folder.\n */\nclass Resolver implements IResolver {\n  /**\n   * Stores resolver settings, such as abi, contract address, and IProvider\n   */\n  readonly settings: Required<RegistrySettings>;\n\n  /**\n   * Stores the provider to connect to blockchain\n   */\n  protected readonly _provider: providers.Provider;\n\n  /**\n   * Stores the smart contract instance with read functionality available\n   */\n  protected _contract: Contract;\n\n  /**\n   * Constructor\n   *\n   * @param settings - Settings to connect to Ethr registry\n   * @param provider - Ethers provider. Can be obtained from getProvider(providerSettings)\n   */\n\n  constructor(provider: providers.Provider, settings: RegistrySettings) {\n    this._provider = provider;\n    this.settings = { abi: ethrReg.abi, method: Methods.Erc1056, ...settings };\n    this._contract = new Contract(settings.address, this.settings.abi, this._provider);\n  }\n\n  /**\n   * Resolve DID Document for a given did\n   *\n   * @example\n   * ```typescript\n   * import { Resolver } from '@ew-did-registry/did-resolver';\n   *\n   * const resolver = new Resolver(provider, resolverSettings);\n   * const didDocument = await resolver.read(did);\n   * ```\n   *\n   * @param did - entity identifier, which is associated with DID Document\n   * @returns {Promise<IDIDDocument>}\n   */\n  private async _read(\n    did: string,\n    selector?: DocumentSelector,\n  ): Promise<IDIDDocument> {\n    const match = did.match(DIDPattern);\n    if (!match) {\n      throw new Error('Invalid did provided');\n    }\n    const address = match[1];\n\n    const _document = {\n      owner: address,\n      topBlock: BigNumber.from(0),\n      authentication: {},\n      publicKey: {},\n      service: {},\n      attributes: new Map(),\n    };\n    try {\n      await fetchDataFromEvents(\n        did,\n        _document,\n        this.settings,\n        this._contract,\n        this._provider,\n        selector,\n      );\n      const document = wrapDidDocument(did, _document);\n      return document;\n    } catch (error) {\n      if (error.toString() === 'Error: Blockchain address did not interact with smart contract') {\n        const didDocument = wrapDidDocument(did, _document);\n        return didDocument;\n      }\n      throw error;\n    }\n  }\n\n  async read(did: string): Promise<IDIDDocument> {\n    return this._read(did) as Promise<IDIDDocument>;\n  }\n\n  async readAttribute(\n    did: string,\n    selector: DocumentSelector,\n  ): Promise<IPublicKey | IServiceEndpoint | IAuthentication | undefined> {\n    const doc = await this._read(did, selector);\n    return query(doc, selector);\n  }\n\n  /**\n   * Returns the Ethereum address of current identity owner\n   *\n   * @param { string } did - did of identity of interest\n   * @returns Promise<string>\n   */\n  async identityOwner(did: string): Promise<string> {\n    const [, , id] = did.split(':');\n    let owner;\n    try {\n      owner = await this._contract.identityOwner(id);\n    } catch (error) {\n      throw new Error(error);\n    }\n    return owner;\n  }\n\n  /**\n   * Performs the check if the delegate is valid for particular did\n   * Return boolean\n   *\n   * @param { string } identityDID - did of identity of interest\n   * @param { DelegateTypes } delegateType - type of delegate of interest\n   * @param { delegateDID } did - did of delegate of interest\n   * @returns Promise<boolean>\n   */\n  async validDelegate(\n    identityDID: string,\n    delegateType: DelegateTypes,\n    delegateDID: string,\n  ): Promise<boolean> {\n    const bytesType = formatBytes32String(delegateType);\n    const [, , identityAddress] = identityDID.split(':');\n    const [, , delegateAddress] = delegateDID.split(':');\n\n    let valid;\n    try {\n      valid = await this._contract.validDelegate(identityAddress, bytesType, delegateAddress);\n    } catch (error) {\n      throw new Error(error);\n    }\n\n    return valid;\n  }\n\n  async readOwnerPubKey(did: string): Promise<string | undefined> {\n    const selector = {\n      publicKey: { id: `${did}#${KeyTags.OWNER}` },\n    };\n    const pk = await this.readAttribute(\n      did,\n      selector,\n    );\n    const publicKeyHex = pk ? ((pk as IPublicKey).publicKeyHex as string) : undefined;\n    if (!publicKeyHex) {\n      return undefined;\n    }\n    if (publicKeyHex.length === compressedSecp256k1KeyLength + 2 && publicKeyHex.substring(0, 2) === '0x') {\n      return publicKeyHex.substring(2);\n    }\n    if (publicKeyHex.length === compressedSecp256k1KeyLength) {\n      return publicKeyHex;\n    }\n    return undefined;\n  }\n\n  async readFromBlock(\n    did: string,\n    topBlock: BigNumber,\n  ): Promise<IDIDLogData> {\n    const [, , address] = did.split(':');\n    const _document = {\n      owner: address,\n      topBlock,\n      authentication: {},\n      publicKey: {},\n      service: {},\n      attributes: new Map(),\n    };\n    await fetchDataFromEvents(did, _document, this.settings, this._contract, this._provider);\n    return { ..._document };\n  }\n\n  async lastBlock(did: string): Promise<BigNumber> {\n    const [, , address] = did.split(':');\n    return this._contract.changed(address);\n  }\n}\n\nexport default Resolver;\n"]}},"error":null,"hash":"21197cfd5ecccb1b170770295d4c6b6d","cacheData":{"env":{}}}