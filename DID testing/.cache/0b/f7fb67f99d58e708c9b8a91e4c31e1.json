{"id":"node_modules/@ew-did-registry/jwt/dist/index.js","dependencies":[{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\index.js.map","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\src\\index.ts","includedInParent":true,"mtime":499162500000},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\package.json","includedInParent":true,"mtime":1643668307056},{"name":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\package.json","includedInParent":true,"mtime":1642815160318},{"name":"jsonwebtoken","loc":{"line":33,"column":33},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\index.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\jsonwebtoken\\index.js"},{"name":"./sign","loc":{"line":34,"column":23},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\index.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\sign.js"},{"name":"./verify","loc":{"line":35,"column":25},"parent":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\index.js","resolved":"C:\\Users\\Ilya\\Documents\\Jaar3Informatica\\Bachelorproef\\DID testing\\node_modules\\@ew-did-registry\\jwt\\dist\\verify.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JWT = void 0;\n/* eslint-disable no-restricted-syntax */\nconst jwt = __importStar(require(\"jsonwebtoken\"));\nconst sign_1 = require(\"./sign\");\nconst verify_1 = require(\"./verify\");\nclass JWT {\n    /**\n     * Key pair has to be passed on construction to JWT\n     * @param {Keys} keys\n     */\n    constructor(signerMethod) {\n        const keys = signerMethod;\n        const signer = signerMethod;\n        if (keys.privateKey && keys.sign && keys.verify) {\n            this.sign = sign_1.createSignWithKeys(keys);\n        }\n        else {\n            this.sign = sign_1.createSignWithEthersSigner(signer);\n        }\n    }\n    /**\n     * If the signature is correct, method returns decoded JWT payload\n     *\n     * @example\n     * ```typescript\n     * import { Keys } from '@ew-did-registry/keys';\n     * import { JWT } from '@ew-did-registry/jwt';\n     *\n     * const AliceKeyPair = new Keys();\n     * const BobKeyPair = new Keys();\n     * const jwtAlice = new JWT(AliceKeyPair);\n     * const jwtBob = new JWT(BobKeyPair);\n     * const payload = {claim: 'test'};\n     *\n     * const token = await jwtAlice.sign(payload, { algorithm: 'ES256' });\n     *\n     * let decoded;\n     *\n     * try {\n     *   decoded = await jwtBob.verify(token, AliceKeyPair.publicKey);\n     *   console.log(decoded);\n     * } catch(e) {\n     *   console.log(e);\n     * }\n     * ```\n     *\n     * @param {string} token\n     * @param {string} publicKey\n     * @param {object} options\n     * @returns {Promise<object>}\n     */\n    verify(token, publicKey, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const verifications = [];\n            for (const verifyMethod of verify_1.verificationMethods) {\n                verifications.push(verifyMethod(token, publicKey, options));\n            }\n            const results = yield Promise.all(Array.from(verifications, (item) => item\n                .then((value) => (Object.assign({}, value)))\n                .catch((reason) => ({ success: false, payload: reason }))));\n            for (const result of results) {\n                if (result.success) {\n                    return result.payload;\n                }\n            }\n            throw new Error('invalid signature');\n        });\n    }\n    /**\n     * Return decoded JWT payload without verifying signature\n     *\n     * @example\n     * ```typescript\n     * import { Keys } from '@ew-did-registry/keys';\n     * import { JWT } from '@ew-did-registry/jwt';\n     *\n     * const AliceKeyPair = new Keys();\n     * const BobKeyPair = new Keys();\n     * const jwtAlice = new JWT(AliceKeyPair);\n     * const jwtBob = new JWT(BobKeyPair);\n     * const payload = {claim: 'test'};\n     *\n     * const token = await jwtAlice.sign(payload, { algorithm: 'ES256' });\n     *\n     * const decoded = jwtBob.decode(token, {complete: true});\n     * console.log(decoded.header);\n     * console.log(decoded.payload.did);\n     * ```\n     *\n     * @param {string} token\n     * @param {object} options\n     * @returns string | { [key: string]: any }\n     */\n    decode(token, options) {\n        return jwt.decode(token, options) || '';\n    }\n}\nexports.JWT = JWT;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAAyC;AACzC,kDAAoC;AAKpC,iCAEgB;AAChB,qCAA+C;AAE/C,MAAM,GAAG;IA6BP;;;OAGG;IACH,YAAY,YAA4B;QACtC,MAAM,IAAI,GAAG,YAAqB,CAAC;QACnC,MAAM,MAAM,GAAG,YAAsB,CAAC;QACtC,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;YAC/C,IAAI,CAAC,IAAI,GAAG,yBAAkB,CAAC,IAAI,CAAC,CAAC;SACtC;aAAM;YACL,IAAI,CAAC,IAAI,GAAG,iCAA0B,CAAC,MAAM,CAAC,CAAC;SAChD;IACH,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA8BG;IACG,MAAM,CACV,KAAa,EACb,SAAiB,EACjB,OAAiC;;YAEjC,MAAM,aAAa,GAAG,EAAE,CAAC;YACzB,KAAK,MAAM,YAAY,IAAI,4BAAmB,EAAE;gBAC9C,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;aAC7D;YACD,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI;iBACvE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,mBAAM,KAAK,EAAG,CAAC;iBAC/B,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAC9D,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,IAAI,MAAM,CAAC,OAAO,EAAE;oBAClB,OAAO,MAAM,CAAC,OAAO,CAAC;iBACvB;aACF;YACD,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;QACvC,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;OAwBG;IACH,MAAM,CAAC,KAAa,EAAE,OAAgB;QAGpC,OAAO,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC;IAC1C,CAAC;CACF;AAGC,kBAAG","sourcesContent":["/* eslint-disable no-restricted-syntax */\nimport * as jwt from 'jsonwebtoken';\nimport { Signer } from 'ethers';\n\nimport { IKeys } from '@ew-did-registry/keys';\nimport { IJWT } from './interface';\nimport {\n  createSignWithEthersSigner, createSignWithKeys, JwtOptions, JwtPayload,\n} from './sign';\nimport { verificationMethods } from './verify';\n\nclass JWT implements IJWT {\n  /**\n   * Sign payload and return JWT\n   *\n   * @example\n   * ```typescript\n   * import { Keys } from '@ew-did-registry/keys';\n   * import { JWT } from '@ew-did-registry/jwt';\n   *\n   * const keyPair = new Keys();\n   * const jwt = new JWT(keyPair);\n   * const payload = {claim: 'test'};\n   * let token;\n   *\n   * try {\n   *   token = await jwt.sign(payload, { algorithm: 'ES256' });\n   *   console.log(token);\n   * } catch(e) {\n   *   console.log(e);\n   * }\n   * ```\n   * @param {object} payload\n   * @param {object} options\n   * @returns {Promise<string>}\n   */\n  public sign: (\n    payload: string | JwtPayload,\n    options?: JwtOptions) => Promise<string>;\n\n  /**\n   * Key pair has to be passed on construction to JWT\n   * @param {Keys} keys\n   */\n  constructor(signerMethod: IKeys | Signer) {\n    const keys = signerMethod as IKeys;\n    const signer = signerMethod as Signer;\n    if (keys.privateKey && keys.sign && keys.verify) {\n      this.sign = createSignWithKeys(keys);\n    } else {\n      this.sign = createSignWithEthersSigner(signer);\n    }\n  }\n\n  /**\n   * If the signature is correct, method returns decoded JWT payload\n   *\n   * @example\n   * ```typescript\n   * import { Keys } from '@ew-did-registry/keys';\n   * import { JWT } from '@ew-did-registry/jwt';\n   *\n   * const AliceKeyPair = new Keys();\n   * const BobKeyPair = new Keys();\n   * const jwtAlice = new JWT(AliceKeyPair);\n   * const jwtBob = new JWT(BobKeyPair);\n   * const payload = {claim: 'test'};\n   *\n   * const token = await jwtAlice.sign(payload, { algorithm: 'ES256' });\n   *\n   * let decoded;\n   *\n   * try {\n   *   decoded = await jwtBob.verify(token, AliceKeyPair.publicKey);\n   *   console.log(decoded);\n   * } catch(e) {\n   *   console.log(e);\n   * }\n   * ```\n   *\n   * @param {string} token\n   * @param {string} publicKey\n   * @param {object} options\n   * @returns {Promise<object>}\n   */\n  async verify(\n    token: string,\n    publicKey: string,\n    options?: Record<string, unknown>,\n  ): Promise<object> {\n    const verifications = [];\n    for (const verifyMethod of verificationMethods) {\n      verifications.push(verifyMethod(token, publicKey, options));\n    }\n    const results = await Promise.all(Array.from(verifications, (item) => item\n      .then((value) => ({ ...value }))\n      .catch((reason) => ({ success: false, payload: reason }))));\n    for (const result of results) {\n      if (result.success) {\n        return result.payload;\n      }\n    }\n    throw new Error('invalid signature');\n  }\n\n  /**\n   * Return decoded JWT payload without verifying signature\n   *\n   * @example\n   * ```typescript\n   * import { Keys } from '@ew-did-registry/keys';\n   * import { JWT } from '@ew-did-registry/jwt';\n   *\n   * const AliceKeyPair = new Keys();\n   * const BobKeyPair = new Keys();\n   * const jwtAlice = new JWT(AliceKeyPair);\n   * const jwtBob = new JWT(BobKeyPair);\n   * const payload = {claim: 'test'};\n   *\n   * const token = await jwtAlice.sign(payload, { algorithm: 'ES256' });\n   *\n   * const decoded = jwtBob.decode(token, {complete: true});\n   * console.log(decoded.header);\n   * console.log(decoded.payload.did);\n   * ```\n   *\n   * @param {string} token\n   * @param {object} options\n   * @returns string | { [key: string]: any }\n   */\n  decode(token: string, options?: object): string | {\n    [key: string]: string | object;\n  } {\n    return jwt.decode(token, options) || '';\n  }\n}\n\nexport {\n  JWT,\n  IJWT,\n};\n"]}},"error":null,"hash":"304f17530bc39610e71fa44ce0c45118","cacheData":{"env":{}}}